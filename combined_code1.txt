/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "string.h"
#include <stdbool.h>

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
#if defined ( __ICCARM__ ) /*!< IAR Compiler */

#pragma location=0x30040000
ETH_DMADescTypeDef  DMARxDscrTab[ETH_RX_DESC_CNT]; /* Ethernet Rx DMA Descriptors */
#pragma location=0x30040060
ETH_DMADescTypeDef  DMATxDscrTab[ETH_TX_DESC_CNT]; /* Ethernet Tx DMA Descriptors */
#pragma location=0x30040200
uint8_t Rx_Buff[ETH_RX_DESC_CNT][ETH_MAX_PACKET_SIZE]; /* Ethernet Receive Buffers */

#elif defined ( __CC_ARM )  /* MDK ARM Compiler */

__attribute__((at(0x30040000))) ETH_DMADescTypeDef  DMARxDscrTab[ETH_RX_DESC_CNT]; /* Ethernet Rx DMA Descriptors */
__attribute__((at(0x30040060))) ETH_DMADescTypeDef  DMATxDscrTab[ETH_TX_DESC_CNT]; /* Ethernet Tx DMA Descriptors */
__attribute__((at(0x30040200))) uint8_t Rx_Buff[ETH_RX_DESC_CNT][ETH_MAX_PACKET_SIZE]; /* Ethernet Receive Buffer */

#elif defined ( __GNUC__ ) /* GNU Compiler */

ETH_DMADescTypeDef DMARxDscrTab[ETH_RX_DESC_CNT] __attribute__((section(".RxDecripSection"))); /* Ethernet Rx DMA Descriptors */
ETH_DMADescTypeDef DMATxDscrTab[ETH_TX_DESC_CNT] __attribute__((section(".TxDecripSection")));   /* Ethernet Tx DMA Descriptors */
uint8_t Rx_Buff[ETH_RX_DESC_CNT][ETH_MAX_PACKET_SIZE] __attribute__((section(".RxArraySection"))); /* Ethernet Receive Buffers */

#endif

ETH_TxPacketConfig TxConfig;
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

DAC_HandleTypeDef hdac1;
DMA_HandleTypeDef hdma_dac1_ch1;

ETH_HandleTypeDef heth;

TIM_HandleTypeDef htim1;

UART_HandleTypeDef huart3;

PCD_HandleTypeDef hpcd_USB_OTG_FS;

/* USER CODE BEGIN PV */
uint8_t txBuf[]={1,2,3};
uint8_t rxBuf[50];
uint8_t dst[5];
uint8_t src[5];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ETH_Init(void);
static void MX_USART3_UART_Init(void);
static void MX_DMA_Init(void);
static void MX_ADC1_Init(void);
static void MX_DAC1_Init(void);
static void MX_USB_OTG_FS_PCD_Init(void);
static void MX_TIM1_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
#include <math.h>

#define PI 3.1415926
#define ADC_BUF_SIZE 20000
#define pi 3.14159265359

// User ID
char userID[2] = "00";

uint16_t ADC_buff[ADC_BUF_SIZE];
int record_done = 0;
uint16_t ADC_buff1[ADC_BUF_SIZE];
uint16_t ADC_buff2[ADC_BUF_SIZE];
int ADC_Finished = 0;
int record_done1 = 0;
int record_done2 = 0;
int play_done = 1;
int start_done = 0; // track if starting point has been found
int msg_done = 0; // track if message part has done


#define ARRAYLENGTH 32
int reference_sine_1[ARRAYLENGTH];

int mag_print_1;

char *decoder(char *str, char *ret);
char singleDecoder(char *str);
char *text_message(char *digit1, char *result);
void *message_encode();

#define PACKLEN 100
#define HDRLEN 8
int startpoint_num = 8;
int endpoint_num = 6;
int reference_sine_2[ARRAYLENGTH];


int state = 0; // state number
const int st_amp = 3900; // amplitude for starting point
int st_counter = 0; // count successive starting point square wave
const int st_num = 8; // # for successive square waves
#define global_array_size 20000 // global array size, need to be large enough to hold everything after starting point
uint16_t global_array[global_array_size]; // a global array to store everything after starting point
int global_index = 0; // an index to track global array length
int ed_counter = 0; // count successive ending point square wave
const int ed_amp = 3000; // amplitude for ending point
const int ed_range = 250; // upper or lower range for ending amplitude
const int ed_num = 6; // successive index for ending point
int* message_pointer = NULL; // a pointer point to message array
#define header_len 4 // length of header part
int global_counter = 0;

int ADC_buff_flag1 = 1;  // 1: recording;  0: ready;
int ADC_buff_flag2 = 0;

int cur_index = 0; // mark current index
int header_done = 0; // mark header state
int end_done = 0; // mark end state
int header_array[header_len]; // an array contain header values
char converted_header_array[header_len]="";
char dest_array[2] = "";

// GLOBAL VARIABLE
char converted_array[10000] = ""; // an converted array with 0, 1, or 3
const int noise_amp = 1024;       // noise amplitude
const int noise_range = 250;      // upper or lower range of the noise amplitude
const int sine_len = 32;          // length of the sine wave
int error_state = 0;              // mark if there is an error to deal with

// GLOBAL USER VARIABLE
char userA[2] = "00";
char userB[2] = "01";
char userC[2] = "10";
char all[2] = "11";

// the function is used to convert message_array into an array with 0, 1, or 3
void message_array_converter(char converted_array[], int global_array[], int message_len, const int sine_len, const int noise_amp, const int noise_range, int *error_state);
// message_len = global_index - header_len - ed_num;

// the function is used to check if there is a sine wave
// return true for sine wave
// return false for zero amplitude or noise
bool check_sine_wave(int global_array[], int start_index, const int sine_len, const int noise_amp, const int noise_range, int *error_state, int message_len);

char* decoder(char *str, char *ret);
char singleDecoder(char *str);
char* text_message(char *digit1, char *result);

void decoding();
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ETH_Init();
  MX_USART3_UART_Init();
  MX_DMA_Init();
  MX_ADC1_Init();
  MX_DAC1_Init();
  MX_USB_OTG_FS_PCD_Init();
  MX_TIM1_Init();
  /* USER CODE BEGIN 2 */
  if(HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET,ADC_SINGLE_ENDED) != HAL_OK){
  	  Error_Handler();
    }
  HAL_TIM_Base_Start(&htim1);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while(1)
  {
	  HAL_Delay(500);
	  message_encode();

	  while (1)
	  {
		  /* USER CODE END WHILE */

		  /* USER CODE BEGIN 3 */
		  HAL_Delay(500);
		  //void decoding()

		  if (HAL_ADC_Start_DMA(&hadc1, (uint32_t *)&ADC_buff, ADC_BUF_SIZE) != HAL_OK) {
			  Error_Handler();
		  }

		  while (record_done == 0){  }

		  //code here
		  // start part
		  if (start_done == 0)
		  {
			  for(int i = 0; i < ADC_BUF_SIZE; i++)
			  {
				  if(ADC_buff[i] >= st_amp)
				  {
					  st_counter++;
				  }

				  else
				  {
					  st_counter = 0;
				  }

				  if(st_counter >= st_num)
				  {
					  start_done = 1;
					  cur_index = i+1;
					  break;
				  }
			  }
		  }


		  // end point
		  if (end_done == 0 && start_done == 1)
		  {
			  for(int i = cur_index; i < ADC_BUF_SIZE; i++)
			  {
				  if(ADC_buff[i] >= (ed_amp-ed_range) && ADC_buff[i]<= (ed_amp+ed_range))
				  {
					  ed_counter++;
				  }

				  else
				  {
					  ed_counter = 0;
				  }

				  global_array[global_index++] = ADC_buff[i];

				  if(ed_counter >= ed_num)
				  {
					  end_done = 1;
					  break;
				  }
			  }
			  cur_index = 0; // reset current index
		  }

		  if (end_done == 1)
		  {
			  // fulfill header array
			  for (int i=0;i<header_len;i++)
			  {
				  header_array[i] = global_array[i];
			  }

			  // Convert header array into 1 or 0
			  for (int i=0; i < header_len; i++)
			  {
				  if(header_array[i] < noise_amp)
					  converted_header_array[i] = '0';

				  else
					  converted_header_array[i] = '1';
			  }
			  //header_array_converter(converted_header_array, header_array, noise_amp, header_len);

			  int message_array[global_index - header_len - ed_num]; // Create a message array

			  for(int i=header_len; i < (global_index - ed_num);i++)
			  {
				  message_array[i-header_len] = global_array[i];
			  }

			  int message_len = global_index - header_len - ed_num;
			  message_array_converter(converted_array, message_array, message_len, sine_len, noise_amp, noise_range, &error_state);

			  if (error_state == 1)
			  {
				  converted_array[strlen(converted_array) - 1] = '\0';
			  }

			  break;
		  }

	  }
	  dest_array[0] = converted_header_array[2];
	  dest_array[1] = converted_header_array[3];
	  if(!strcmp(dest_array,userID) || !strcmp(dest_array, all))
	  {
		  char source_user[2] = "";
		  char source_user_name;
		  source_user[0] = converted_header_array[0];
		  source_user[1] = converted_header_array[1];
		  if(!strcmp(source_user,userA))
			  source_user_name = 'A';

		  else if(!strcmp(source_user,userB))
			  source_user_name = 'B';

		  else if(!strcmp(source_user,userC))
			  source_user_name = 'C';

		  printf("The Source User is: %c\n", source_user_name);
		  printf("\nMorse decode digit: %s\n", converted_array);
		  //printf("\nSize of digit_1: %d\n", sizeof(digit_1)/ sizeof(digit_1[0]));

		  //part2: convert Morse code to characters abc...z012...9
		  char result[1000]="";
		  char output[1000]="";
		  text_message(converted_array, result);
		  decoder(result, output);

		  printf("\nOutput: %s\n", output);
	  }

	  else
	  {
		  printf("\nYou are BLOCKED !!!\n");
	  }



	  int a = 1;

  }




  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
  /** Macro to configure the PLL clock source
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 18;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 3;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOMEDIUM;
  RCC_OscInitStruct.PLL.PLLFRACN = 6144;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */
  /** Common config
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.NbrOfConversion = 1;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T1_TRGO;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_ONESHOT;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc1.Init.OversamplingMode = DISABLE;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }
  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
  {
    Error_Handler();
  }
  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_15;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  sConfig.OffsetSignedSaturation = DISABLE;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief DAC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_DAC1_Init(void)
{

  /* USER CODE BEGIN DAC1_Init 0 */

  /* USER CODE END DAC1_Init 0 */

  DAC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN DAC1_Init 1 */

  /* USER CODE END DAC1_Init 1 */
  /** DAC Initialization
  */
  hdac1.Instance = DAC1;
  if (HAL_DAC_Init(&hdac1) != HAL_OK)
  {
    Error_Handler();
  }
  /** DAC channel OUT1 config
  */
  sConfig.DAC_SampleAndHold = DAC_SAMPLEANDHOLD_DISABLE;
  sConfig.DAC_Trigger = DAC_TRIGGER_T1_TRGO;
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
  sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_DISABLE;
  sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;
  if (HAL_DAC_ConfigChannel(&hdac1, &sConfig, DAC_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN DAC1_Init 2 */

  /* USER CODE END DAC1_Init 2 */

}

/**
  * @brief ETH Initialization Function
  * @param None
  * @retval None
  */
static void MX_ETH_Init(void)
{

  /* USER CODE BEGIN ETH_Init 0 */

  /* USER CODE END ETH_Init 0 */

   static uint8_t MACAddr[6];

  /* USER CODE BEGIN ETH_Init 1 */

  /* USER CODE END ETH_Init 1 */
  heth.Instance = ETH;
  MACAddr[0] = 0x00;
  MACAddr[1] = 0x80;
  MACAddr[2] = 0xE1;
  MACAddr[3] = 0x00;
  MACAddr[4] = 0x00;
  MACAddr[5] = 0x00;
  heth.Init.MACAddr = &MACAddr[0];
  heth.Init.MediaInterface = HAL_ETH_RMII_MODE;
  heth.Init.TxDesc = DMATxDscrTab;
  heth.Init.RxDesc = DMARxDscrTab;
  heth.Init.RxBuffLen = 1524;

  /* USER CODE BEGIN MACADDRESS */

  /* USER CODE END MACADDRESS */

  if (HAL_ETH_Init(&heth) != HAL_OK)
  {
    Error_Handler();
  }

  memset(&TxConfig, 0 , sizeof(ETH_TxPacketConfig));
  TxConfig.Attributes = ETH_TX_PACKETS_FEATURES_CSUM | ETH_TX_PACKETS_FEATURES_CRCPAD;
  TxConfig.ChecksumCtrl = ETH_CHECKSUM_IPHDR_PAYLOAD_INSERT_PHDR_CALC;
  TxConfig.CRCPadCtrl = ETH_CRC_PAD_INSERT;
  /* USER CODE BEGIN ETH_Init 2 */

  /* USER CODE END ETH_Init 2 */

}

/**
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 0;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 9374;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * @brief USB_OTG_FS Initialization Function
  * @param None
  * @retval None
  */
static void MX_USB_OTG_FS_PCD_Init(void)
{

  /* USER CODE BEGIN USB_OTG_FS_Init 0 */

  /* USER CODE END USB_OTG_FS_Init 0 */

  /* USER CODE BEGIN USB_OTG_FS_Init 1 */

  /* USER CODE END USB_OTG_FS_Init 1 */
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 9;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.battery_charging_enable = ENABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USB_OTG_FS_Init 2 */

  /* USER CODE END USB_OTG_FS_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOE_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(USB_OTG_FS_PWR_EN_GPIO_Port, USB_OTG_FS_PWR_EN_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD1_Pin LD3_Pin */
  GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : USB_OTG_FS_PWR_EN_Pin */
  GPIO_InitStruct.Pin = USB_OTG_FS_PWR_EN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(USB_OTG_FS_PWR_EN_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : USB_OTG_FS_OVCR_Pin */
  GPIO_InitStruct.Pin = USB_OTG_FS_OVCR_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(USB_OTG_FS_OVCR_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LD2_Pin */
  GPIO_InitStruct.Pin = LD2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

}

/* USER CODE BEGIN 4 */

char* text_message(char *digit1, char *result)
{
    int i = 0;
    int counter = 0;
    char temp = 'a';
    char space = ' ';
    char slash = '/';
    //printf("%c", digit1[i]);
    while (1)
    {
        if (digit1[i] == '1')
            temp = '.';

        else if (digit1[i] == '3')
            temp = '-';

        else
            break;

        i++;
        while (digit1[i] == '0')
        {
            counter++;
            i++;
        }

        if (counter == 1)
        {
            strncat(result, &temp, 1);
        }

        else if (counter == 3)
        {
            strncat(result, &temp, 1);
            strncat(result, &space, 1);
        }

        else if (counter > 3)
        {
            strncat(result, &temp, 1);
            strncat(result, &space, 1);
            strncat(result, &slash, 1);
            strncat(result, &space, 1);
        }

        counter = 0;
    }

    return result;
}

char* decoder(char *str, char *ret)
{
    char temp[10] = "";
    for (int i = 0; i <= strlen(str); i++)
    {
        strncat(temp, &str[i], 1);
        //puts(temp);
        if (str[i] == ' ' || str[i] == '\0')
        {
            char word = singleDecoder(temp);
            strncat(ret, &word, 1);
            memset(temp, 0, sizeof(temp));
        }
    }

    return ret;
}

char singleDecoder(char *str)
{
    if (strcmp(str, ".-") == 0 || strcmp(str, ".- ") == 0)
        return 'A';
    else if (strcmp(str, "-...") == 0 || strcmp(str, "-... ") == 0)
        return 'B';
    else if (strcmp(str, "-.-.") == 0 || strcmp(str, "-.-. ") == 0)
        return 'C';
    else if (strcmp(str, "-..") == 0 || strcmp(str, "-.. ") == 0)
        return 'D';
    else if (strcmp(str, ".") == 0 || strcmp(str, ". ") == 0)
        return 'E';
    else if (strcmp(str, "..-.") == 0 || strcmp(str, "..-. ") == 0)
        return 'F';
    else if (strcmp(str, "--.") == 0 || strcmp(str, "--. ") == 0)
        return 'G';
    else if (strcmp(str, "....") == 0 || strcmp(str, ".... ") == 0)
        return 'H';
    else if (strcmp(str, "..") == 0 || strcmp(str, ".. ") == 0)
        return 'I';
    else if (strcmp(str, ".---") == 0 || strcmp(str, ".--- ") == 0)
        return 'J';
    else if (strcmp(str, "-.-") == 0 || strcmp(str, "-.- ") == 0)
        return 'K';
    else if (strcmp(str, ".-..") == 0 || strcmp(str, ".-.. ") == 0)
        return 'L';
    else if (strcmp(str, "--") == 0 || strcmp(str, "-- ") == 0)
        return 'M';
    else if (strcmp(str, "-.") == 0 || strcmp(str, "-. ") == 0)
        return 'N';
    else if (strcmp(str, "---") == 0 || strcmp(str, "--- ") == 0)
        return 'O';
    else if (strcmp(str, ".--.") == 0 || strcmp(str, ".--. ") == 0)
        return 'P';
    else if (strcmp(str, "--.-") == 0 || strcmp(str, "--.- ") == 0)
        return 'Q';
    else if (strcmp(str, ".-.") == 0 || strcmp(str, ".-. ") == 0)
        return 'R';
    else if (strcmp(str, "...") == 0 || strcmp(str, "... ") == 0)
        return 'S';
    else if (strcmp(str, "-") == 0 || strcmp(str, "- ") == 0)
        return 'T';
    else if (strcmp(str, "..-") == 0 || strcmp(str, "..- ") == 0)
        return 'U';
    else if (strcmp(str, "...-") == 0 || strcmp(str, "...- ") == 0)
        return 'V';
    else if (strcmp(str, ".--") == 0 || strcmp(str, ".-- ") == 0)
        return 'W';
    else if (strcmp(str, "-..-") == 0 || strcmp(str, "-..- ") == 0)
        return 'X';
    else if (strcmp(str, "-.--") == 0 || strcmp(str, "-.-- ") == 0)
        return 'Y';
    else if (strcmp(str, "--..") == 0 || strcmp(str, "--.. ") == 0)
        return 'Z';
    else if (strcmp(str, ".----") == 0 || strcmp(str, ".---- ") == 0)
        return '1';
    else if (strcmp(str, "..---") == 0 || strcmp(str, "..--- ") == 0)
        return '2';
    else if (strcmp(str, "...--") == 0 || strcmp(str, "...-- ") == 0)
        return '3';
    else if (strcmp(str, "....-") == 0 || strcmp(str, "....- ") == 0)
        return '4';
    else if (strcmp(str, ".....") == 0 || strcmp(str, "..... ") == 0)
        return '5';
    else if (strcmp(str, "-....") == 0 || strcmp(str, "-.... ") == 0)
        return '6';
    else if (strcmp(str, "--...") == 0 || strcmp(str, "--... ") == 0)
        return '7';
    else if (strcmp(str, "---..") == 0 || strcmp(str, "---.. ") == 0)
        return '8';
    else if (strcmp(str, "----.") == 0 || strcmp(str, "----. ") == 0)
        return '9';
    else if (strcmp(str, "-----") == 0 || strcmp(str, "----- ") == 0)
        return '0';
    else if (strcmp(str, "/") == 0 || strcmp(str, "/ ") == 0)
        return '_';
    else
        return '\0';
}


void message_array_converter(char converted_array[], int global_array[], int message_len, const int sine_len, const int noise_amp, const int noise_range, int *error_state)
{
    for (int i = 0; i < message_len; i += sine_len)
    {
        // if detected sine wave
        if (check_sine_wave(global_array, i, sine_len, noise_amp, noise_range, error_state, message_len))
        {
            i += sine_len;

            // if successive sine wave
            if (check_sine_wave(global_array, i, sine_len, noise_amp, noise_range, error_state, message_len))
            {
                i += sine_len;
                strcat(converted_array, "3");
            }

            else
            {
                strcat(converted_array, "10");
            }
        }

        else
        {
            strcat(converted_array, "0");
        }
    }
}

bool check_sine_wave(int global_array[], int start_index, const int sine_len, const int noise_amp, const int noise_range, int *error_state, int message_len)
{
    int sine_counter = 0;
    int noise_counter = 0;

    if (start_index + sine_len > message_len)
    {
        // error
        *error_state = 1;

        return false;
    }

    for (int i = start_index; i < (start_index + sine_len); i++)
    {
        if (global_array[i] >= (noise_amp - noise_range) && global_array[i] <= (noise_amp + noise_range))
        {
            noise_counter++;
        }

        else
        {
            sine_counter++;
        }

        if (sine_counter >= (sine_len / 2))
            return true;

        if (noise_counter >= (sine_len / 2))
            return false;
    }
}

/*
void header_array_converter(char converted_header_array[], int header_array[], const int noise_amp, const int header_length)
{
	for (int i=0; i < header_length; i++)
	{
		if(header_array[i] < noise_amp)
			converted_header_array[i] = 0;

		else
			converted_header_array[i] = 1;
	}
}
*/


void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc){
//	if(ADC_buff_flag1 ==0){
//		record_done1= 1;
//		ADC_buff_flag1=1;
//	}
//	else{
//		ADC_buff_flag1=0;
//	}
//
//	if(ADC_buff_flag2 ==0){
//		record_done2= 1;
//		ADC_buff_flag2=1;
//	}
//	else{
//		ADC_buff_flag2=0;
//	}
//	ADC_Finished = 1;

	//global_counter++;
	//global_counter = global_counter % ADC_BUF_SIZE;

	//record_done = 1;


//	if(ADC_buff[0] >= st_amp)
//	{
//		state = 1;
//	}
//
//	else if(ADC_buff[0] <= noise_amp)
//	{
//		state = 0;
//	}

	/*
	if(ADC_buff[global_counter] >= st_amp)
	{
		state = 1;
	}

	else if(ADC_buff[global_counter] <= noise_amp)
	{
		state = 0;
	}
	*/



	// stop function

	if(HAL_ADC_Stop_DMA(&hadc1) != HAL_OK){
		Error_Handler();
	}

	record_done = 1;
//	if (HAL_ADC_Start_DMA(&hadc1, (uint32_t *)&ADC_buff[global_counter], 1) != HAL_OK) {
//		Error_Handler();
//	}

	// suggested possible input parameter
	/*
	(uint32_t *)(&ADC_buff+global_counter)
	(uint32_t *)&(ADC_buff[global_counter])
	(uint32_t *)(ADC_buff[global_counter])
	*/
}



void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef *hdac){
	play_done = 1;
}

int _write(int fd, char *ptr, int len)
{
 HAL_UART_Transmit(&huart3, (uint8_t *) ptr, len, HAL_MAX_DELAY);
 return len;
}

int _read(int fd, char *ptr, int len)
{
 HAL_UART_Receive(&huart3, (uint8_t *) ptr, 1, HAL_MAX_DELAY);
 return 1;
}

void *message_encode(){
	//=====================Rose - header - start ======================================================
		  //Rose - header
		  //1.confirm the source of the sender
		  printf("Your are User(A/B/C) (input one letter only): ");
		  scanf("%s", src);
		  printf("\nThe message source is: User %s\n", src);

		  //2. assign the destination
		  printf("Your message destination is: (A/B/C/all) ");
		  scanf("%s", dst);
		  printf("\nYour destination: %s\n", dst);

		  // generate header
		  //source
		  char header[HDRLEN] = "";
		  unsigned curr=0;
		  switch (src[0]){
		  	  	case 'A':
		  		  	strcat(header, "00");
		  		  	break;
		  		 case 'B':
		  		  	strcat(header, "01");
		  		  	break;
		  		 case 'C':
		  		  	strcat(header, "10");
		  		  	break;
		  		 default:
		  			strcat(header, "11");
		  			break;
		  }
		  curr += 2;

		  //destination
		  switch (dst[0]){
		  	  	case 'A':
		  		  	strcat(header, "00");
		  		  	break;
		  		 case 'B':
		  		  	strcat(header, "01");
		  		  	break;
		  		 case 'C':
		  		  	strcat(header, "10");
		  		  	break;
		  		 case 'a':
		  			strcat(header, "11");
		  		 default:
		  			break;
		  }
		  curr += 2;

		  printf("\nHeader_1 :%s\n", header);
	//==============================Rose - header - end =====================

	//========================INPUT MESSAGE & ENCODE - start ==========================
		  //Use UART/console to create the message
		  printf("Input message: ");
		  scanf("%s", rxBuf);
		  printf("\nYour input info: %s\n", rxBuf);

		  //split fucntion in case the message is too long ???

		  //Encode the message into Morse code
		  char digit[1000] = "";  //change size if the message is longer
		  unsigned currentSize=0;//actual size for digit
		  for(int i =0;i<sizeof(rxBuf);i++)
		  {
			  switch (rxBuf[i])
			  	{
			  	case 'a':
			  		strcat(digit, "103000");
			  		currentSize += 6;
			  		break;
			  	case 'b':
			  		strcat(digit, "3010101000");
			  		currentSize += 10;
			  		break;
			  	case 'c':
			  		strcat(digit, "3010301000");
			  		currentSize += 10;
			  		break;
			  	case 'd':
			  		strcat(digit, "30101000");
			  		currentSize += 8;
			  		break;
			  	case 'e':
			  		strcat(digit, "1000");
			  		currentSize += 4;
			  		break;
			  	case 'f':
			  		strcat(digit, "1010301000");
			  		currentSize += 10;
			  		break;
			  	case 'g':
			  		strcat(digit, "30301000");
			  		currentSize += 8;
			  		break;
			  	case 'h':
			  		strcat(digit, "1010101000");
			  		currentSize += 10;
			  		break;
			  	case 'i':
			  		strcat(digit, "101000");
			  		currentSize += 6;
			  		break;
			  	case 'j':
			  		strcat(digit, "1030303000");
			  		currentSize += 10;
			  		break;
			  	case 'k':
			  		strcat(digit, "30103000");
			  		currentSize += 8;
			  		break;
			  	case 'l':
			  		strcat(digit, "1030101000");
			  		currentSize += 10;
			  		break;
			  	case 'm':
			  		strcat(digit, "303000");
			  		currentSize += 6;
			  		break;
			  	case 'n':
			  		strcat(digit, "301000");
			  		currentSize += 6;
			  		break;
			  	case 'o':
			  		strcat(digit, "30303000");
			  		currentSize += 8;
			  		break;
			  	case 'p':
			  		strcat(digit, "1030301000");
			  		currentSize += 10;
			  		break;
			  	case 'q':
			  		strcat(digit, "3030103000");
			  		currentSize += 10;
			  		break;
			  	case 'r':
			  		strcat(digit, "10301000");
			  		currentSize += 8;
			  		break;
			  	case 's':
			  		strcat(digit, "10101000");
			  		currentSize += 8;
			  		break;
			  	case 't':
			  		strcat(digit, "3000");
			  		currentSize += 4;
			  		break;
			  	case 'u':
			  		strcat(digit, "10103000");
			  		currentSize += 8;
			  		break;
			  	case 'v':
			  		strcat(digit, "1010103000");
			  		currentSize += 10;
			  		break;
			  	case 'w':
			  		strcat(digit, "10303000");
			  		currentSize += 8;
			  		break;
			  	case 'x':
			  		strcat(digit, "3010103000");
			  		currentSize += 10;
			  		break;
			  	case 'y':
			  		strcat(digit, "3010303000");
			  		currentSize += 10;
			  		break;
			  	case 'z':
			  		strcat(digit, "3030101000");
			  		currentSize += 10;
			  		break;
			  	case '1':
			  		strcat(digit, "103030303000");
			  		currentSize += 12;
			  		break;
			  	case '2':
			  		strcat(digit, "101030303000");
			  		currentSize += 12;
			  		break;
			  	case '3':
			  		strcat(digit, "101010303000");
			  		currentSize += 12;
			  		break;
			  	case '4':
			  		strcat(digit, "101010103000");
			  		currentSize += 12;
			  		break;
			  	case '5':
			  		strcat(digit, "101010101000");
			  		currentSize += 12;
			  		break;
			  	case '6':
			  		strcat(digit, "301010101000");
			  		currentSize += 12;
			  		break;
			  	case '7':
			  		strcat(digit, "303010101000");
			  		currentSize += 12;
			  		break;
			  	case '8':
			  		strcat(digit, "303030101000");
			  		currentSize += 12;
			  		break;
			  	case '9':
			  		strcat(digit, "303030301000");
			  		currentSize += 12;
			  		break;
			  	case '0':
			  		strcat(digit, "303030303000");
			  		currentSize += 12;
			  		break;
			  	case '_':
			  		strcat(digit, "0000");
			  		currentSize += 4;
			  		break;
			  	default:
			  		break;
			  	}
		  }

		printf("\nMorse encode: %s\n", digit);


		//===========output header - start================

		int header_sig[4]={0};
		for (int i = 0; i < 4; i++){
			if (header[i] == '1'){
					header_sig[i] = 3800;
				}else{
					header_sig[i] = 0;
			}
		}

		//===========output header - end================


		// produce sine wave for Morse code
		int all[32000];//estimated size - [ARRAYLENGTH*1000sizeof digit] //accumulated output array at transmitting board
		unsigned index = 0; //size of accumulated output array

		for(int c=0;c<currentSize;c++)
		{
			if(digit[c] == '0') // 0 magnitude
			{
				for (int i=0; i<ARRAYLENGTH; i++)
				{
					reference_sine_1[i] = 0*sin(i*2*PI/32); // 0 magnitude
					all[index++] =reference_sine_1[i];
				}
			}
			else if (digit[c] == '1')  // 1 cycle
			{
				for (int i=0; i<ARRAYLENGTH; i++)
						{
							reference_sine_1[i] = 4096*sin(i*2*PI/32);
							all[index++] =reference_sine_1[i];
						}
			}
			else if (digit[c] == '3')  // 3 cycles
			{
				for (int j=0; j<3; j++)
				{
					for (int i=0; i<ARRAYLENGTH; i++)
					{
						reference_sine_1[i] = 4096*sin(i*2*PI/32);
						all[index++] =reference_sine_1[i];
					}
				}
			}
		}

		//shift whole array up and plot
		int all_shift[index];
		for (int i=0; i < index; i++)
		{
			all_shift[i] = (all[i]+4096)/4;
		}

		// convert to uint16_t and plot
		uint16_t ADC_buff_encode[index+1];
		for (int i = 0; i < index; i++)
		{
			ADC_buff_encode[i] = (uint16_t) all_shift[i];
		}


	//========================Implementing Starting and Ending Points ==========================

		 uint16_t start_points[8] = {};

		 for (int i=0; i < startpoint_num; i++)
		 {
		  start_points[i] = 4095;
		 }

		 uint16_t end_points[6] = {};
		 for (int i=0; i < endpoint_num; i++)
		 {
		 end_points[i] = 3000;
		 }
	//======================== Combining header and encoded message ==========================
		int transmit_size = startpoint_num+4+index+6;

		uint16_t ADC_buff_transmit[transmit_size];

		for (int i = 0; i < startpoint_num; i++){
				ADC_buff_transmit[i] =  start_points[i];
			}
		for (int i = startpoint_num; i < (startpoint_num+4); i++){
			ADC_buff_transmit[i] = (uint16_t) header_sig[i-(startpoint_num)];
		}
		for (int i = (startpoint_num+4); i < (transmit_size-6); i++){
			ADC_buff_transmit[i] = ADC_buff_encode[i - (startpoint_num+4)];
		}

		for (int i = (transmit_size - 6); i < (transmit_size); i++){
			ADC_buff_transmit[i] = end_points[i - (transmit_size-6)];
			}
		//pass thru DAC and output

	//printing together
	//	for (int i=0; i < transmit_size; i++) // if do not want 3 last 0s: i<(index-96)
	//	{
	//		mag_print_1 = ADC_buff_transmit[i];
	//		HAL_Delay(10);
	//	}


	//pass thru DAC and output
		if(HAL_DAC_Start_DMA(&hdac1, DAC_CHANNEL_1, ADC_buff_transmit, transmit_size, DAC_ALIGN_12B_R) != HAL_OK){
			Error_Handler();
		}

		int k = 0;
	//========================INPUT MESSAGE & ENCODE - end ==========================



}

/*
int _write(int fd, char *ptr, int len)
{
	HAL_UART_Transmit(&huart3, (uint8_t *) ptr, len, HAL_MAX_DELAY);
	return len;
}

int _read(int fd, char *ptr, int len)
{
	HAL_UART_Receive(&huart3, (uint8_t *) ptr, 1, HAL_MAX_DELAY);
	return 1;
}
*/

/*
int _write(int file, char *ptr, int len)
{
  // Implement your write code here, this is used by puts and printf for example
  int i=0;
  for(i=0 ; i<len ; i++)
    ITM_SendChar((*ptr++));
  return len;
}
*/
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
	HAL_GPIO_WritePin(GPIOB, LD3_Pin, GPIO_PIN_SET);
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
